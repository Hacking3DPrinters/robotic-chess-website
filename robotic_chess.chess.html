<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module robotic_chess.chess</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong><a href="robotic_chess.html"><font color="#ffffff">robotic_chess</font></a>.chess</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:/home/codespace/.python/current/lib/python3.10/site-packages/robotic_chess/chess.py">/home/codespace/.python/current/lib/python3.10/site-packages/robotic_chess/chess.py</a></font></td></tr></table>
    <p></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="chess.html">chess</a><br>
</td><td width="25%" valign=top></td><td width="25%" valign=top></td><td width="25%" valign=top></td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="builtins.html#object">builtins.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="robotic_chess.chess.html#Engine">Engine</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="chess.html#Board">chess.Board</a>(<a href="chess.html#BaseBoard">chess.BaseBoard</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="robotic_chess.chess.html#Board">Board</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="chess.html#Move">chess.Move</a>(<a href="builtins.html#object">builtins.object</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="robotic_chess.chess.html#Move">Move</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Board">class <strong>Board</strong></a>(<a href="chess.html#Board">chess.Board</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Board">Board</a>(fen:&nbsp;'Optional[str]'&nbsp;=&nbsp;'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR&nbsp;w&nbsp;KQkq&nbsp;-&nbsp;0&nbsp;1',&nbsp;*,&nbsp;chess960:&nbsp;'bool'&nbsp;=&nbsp;False)&nbsp;-&amp;gt;&nbsp;'None'<br>
&nbsp;<br>
<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="robotic_chess.chess.html#Board">Board</a></dd>
<dd><a href="chess.html#Board">chess.Board</a></dd>
<dd><a href="chess.html#BaseBoard">chess.BaseBoard</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__annotations__</strong> = {}</dl>

<hr>
Methods inherited from <a href="chess.html#Board">chess.Board</a>:<br>
<dl><dt><a name="Board-__eq__"><strong>__eq__</strong></a>(self, board: 'object') -&gt; 'bool'</dt><dd><tt>Return&nbsp;self==value.</tt></dd></dl>

<dl><dt><a name="Board-__init__"><strong>__init__</strong></a>(self: 'BoardT', fen: 'Optional[str]' = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1', *, chess960: 'bool' = False) -&gt; 'None'</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Board-__repr__"><strong>__repr__</strong></a>(self) -&gt; 'str'</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Board-apply_mirror"><strong>apply_mirror</strong></a>(self: 'BoardT') -&gt; 'None'</dt></dl>

<dl><dt><a name="Board-apply_transform"><strong>apply_transform</strong></a>(self, f: 'Callable[[Bitboard], Bitboard]') -&gt; 'None'</dt></dl>

<dl><dt><a name="Board-can_claim_draw"><strong>can_claim_draw</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;player&nbsp;to&nbsp;move&nbsp;can&nbsp;claim&nbsp;a&nbsp;draw&nbsp;by&nbsp;the&nbsp;fifty-move&nbsp;rule&nbsp;or<br>
by&nbsp;threefold&nbsp;repetition.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;checking&nbsp;the&nbsp;latter&nbsp;can&nbsp;be&nbsp;slow.</tt></dd></dl>

<dl><dt><a name="Board-can_claim_fifty_moves"><strong>can_claim_fifty_moves</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;player&nbsp;to&nbsp;move&nbsp;can&nbsp;claim&nbsp;a&nbsp;draw&nbsp;by&nbsp;the&nbsp;fifty-move&nbsp;rule.<br>
&nbsp;<br>
In&nbsp;addition&nbsp;to&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-is_fifty_moves">is_fifty_moves</a>()`,&nbsp;the&nbsp;fifty-move<br>
rule&nbsp;can&nbsp;also&nbsp;be&nbsp;claimed&nbsp;if&nbsp;there&nbsp;is&nbsp;a&nbsp;legal&nbsp;move&nbsp;that&nbsp;achieves&nbsp;this<br>
condition.</tt></dd></dl>

<dl><dt><a name="Board-can_claim_threefold_repetition"><strong>can_claim_threefold_repetition</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;player&nbsp;to&nbsp;move&nbsp;can&nbsp;claim&nbsp;a&nbsp;draw&nbsp;by&nbsp;threefold&nbsp;repetition.<br>
&nbsp;<br>
Draw&nbsp;by&nbsp;threefold&nbsp;repetition&nbsp;can&nbsp;be&nbsp;claimed&nbsp;if&nbsp;the&nbsp;position&nbsp;on&nbsp;the<br>
board&nbsp;occurred&nbsp;for&nbsp;the&nbsp;third&nbsp;time&nbsp;or&nbsp;if&nbsp;such&nbsp;a&nbsp;repetition&nbsp;is&nbsp;reached<br>
with&nbsp;one&nbsp;of&nbsp;the&nbsp;possible&nbsp;legal&nbsp;moves.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;checking&nbsp;this&nbsp;can&nbsp;be&nbsp;slow:&nbsp;In&nbsp;the&nbsp;worst&nbsp;case<br>
scenario,&nbsp;every&nbsp;legal&nbsp;move&nbsp;has&nbsp;to&nbsp;be&nbsp;tested&nbsp;and&nbsp;the&nbsp;entire&nbsp;game&nbsp;has&nbsp;to<br>
be&nbsp;replayed&nbsp;because&nbsp;there&nbsp;is&nbsp;no&nbsp;incremental&nbsp;transposition&nbsp;table.</tt></dd></dl>

<dl><dt><a name="Board-castling_shredder_fen"><strong>castling_shredder_fen</strong></a>(self) -&gt; 'str'</dt></dl>

<dl><dt><a name="Board-castling_xfen"><strong>castling_xfen</strong></a>(self) -&gt; 'str'</dt></dl>

<dl><dt><a name="Board-checkers"><strong>checkers</strong></a>(self) -&gt; 'SquareSet'</dt><dd><tt>Gets&nbsp;the&nbsp;pieces&nbsp;currently&nbsp;giving&nbsp;check.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;:class:`set&nbsp;of&nbsp;squares&nbsp;&lt;chess.SquareSet&gt;`.</tt></dd></dl>

<dl><dt><a name="Board-checkers_mask"><strong>checkers_mask</strong></a>(self) -&gt; 'Bitboard'</dt></dl>

<dl><dt><a name="Board-chess960_pos"><strong>chess960_pos</strong></a>(self, *, ignore_turn: 'bool' = False, ignore_castling: 'bool' = False, ignore_counters: 'bool' = True) -&gt; 'Optional[int]'</dt><dd><tt>Gets&nbsp;the&nbsp;Chess960&nbsp;starting&nbsp;position&nbsp;index&nbsp;between&nbsp;0&nbsp;and&nbsp;956,<br>
or&nbsp;``None``&nbsp;if&nbsp;the&nbsp;current&nbsp;position&nbsp;is&nbsp;not&nbsp;a&nbsp;Chess960&nbsp;starting<br>
position.<br>
&nbsp;<br>
By&nbsp;default,&nbsp;white&nbsp;to&nbsp;move&nbsp;(**ignore_turn**)&nbsp;and&nbsp;full&nbsp;castling&nbsp;rights<br>
(**ignore_castling**)&nbsp;are&nbsp;required,&nbsp;but&nbsp;move&nbsp;counters<br>
(**ignore_counters**)&nbsp;are&nbsp;ignored.</tt></dd></dl>

<dl><dt><a name="Board-clean_castling_rights"><strong>clean_castling_rights</strong></a>(self) -&gt; 'Bitboard'</dt><dd><tt>Returns&nbsp;valid&nbsp;castling&nbsp;rights&nbsp;filtered&nbsp;from<br>
:data:`~chess.<a href="#Board">Board</a>.castling_rights`.</tt></dd></dl>

<dl><dt><a name="Board-clear"><strong>clear</strong></a>(self) -&gt; 'None'</dt><dd><tt>Clears&nbsp;the&nbsp;board.<br>
&nbsp;<br>
Resets&nbsp;move&nbsp;stack&nbsp;and&nbsp;move&nbsp;counters.&nbsp;The&nbsp;side&nbsp;to&nbsp;move&nbsp;is&nbsp;white.&nbsp;There<br>
are&nbsp;no&nbsp;rooks&nbsp;or&nbsp;kings,&nbsp;so&nbsp;castling&nbsp;rights&nbsp;are&nbsp;removed.<br>
&nbsp;<br>
In&nbsp;order&nbsp;to&nbsp;be&nbsp;in&nbsp;a&nbsp;valid&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-status">status</a>()`,&nbsp;at&nbsp;least&nbsp;kings<br>
need&nbsp;to&nbsp;be&nbsp;put&nbsp;on&nbsp;the&nbsp;board.</tt></dd></dl>

<dl><dt><a name="Board-clear_board"><strong>clear_board</strong></a>(self) -&gt; 'None'</dt><dd><tt>Clears&nbsp;the&nbsp;board.<br>
&nbsp;<br>
:class:`~chess.<a href="#Board">Board</a>`&nbsp;also&nbsp;clears&nbsp;the&nbsp;move&nbsp;stack.</tt></dd></dl>

<dl><dt><a name="Board-clear_stack"><strong>clear_stack</strong></a>(self) -&gt; 'None'</dt><dd><tt>Clears&nbsp;the&nbsp;move&nbsp;stack.</tt></dd></dl>

<dl><dt><a name="Board-copy"><strong>copy</strong></a>(self: 'BoardT', *, stack: 'Union[bool, int]' = True) -&gt; 'BoardT'</dt><dd><tt>Creates&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;board.<br>
&nbsp;<br>
Defaults&nbsp;to&nbsp;copying&nbsp;the&nbsp;entire&nbsp;move&nbsp;stack.&nbsp;Alternatively,&nbsp;*stack*&nbsp;can<br>
be&nbsp;``False``,&nbsp;or&nbsp;an&nbsp;integer&nbsp;to&nbsp;copy&nbsp;a&nbsp;limited&nbsp;number&nbsp;of&nbsp;moves.</tt></dd></dl>

<dl><dt><a name="Board-epd"><strong>epd</strong></a>(self, *, shredder: 'bool' = False, en_passant: '_EnPassantSpec' = 'legal', promoted: 'Optional[bool]' = None, **operations: 'Union[None, str, int, float, Move, Iterable[Move]]') -&gt; 'str'</dt><dd><tt>Gets&nbsp;an&nbsp;EPD&nbsp;representation&nbsp;of&nbsp;the&nbsp;current&nbsp;position.<br>
&nbsp;<br>
See&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-fen">fen</a>()`&nbsp;for&nbsp;FEN&nbsp;formatting&nbsp;options&nbsp;(*shredder*,<br>
*ep_square*&nbsp;and&nbsp;*promoted*).<br>
&nbsp;<br>
EPD&nbsp;operations&nbsp;can&nbsp;be&nbsp;given&nbsp;as&nbsp;keyword&nbsp;arguments.&nbsp;Supported&nbsp;operands<br>
are&nbsp;strings,&nbsp;integers,&nbsp;finite&nbsp;floats,&nbsp;legal&nbsp;moves&nbsp;and&nbsp;``None``.<br>
Additionally,&nbsp;the&nbsp;operation&nbsp;``pv``&nbsp;accepts&nbsp;a&nbsp;legal&nbsp;variation&nbsp;as<br>
a&nbsp;list&nbsp;of&nbsp;moves.&nbsp;The&nbsp;operations&nbsp;``am``&nbsp;and&nbsp;``bm``&nbsp;accept&nbsp;a&nbsp;list&nbsp;of<br>
legal&nbsp;moves&nbsp;in&nbsp;the&nbsp;current&nbsp;position.<br>
&nbsp;<br>
The&nbsp;name&nbsp;of&nbsp;the&nbsp;field&nbsp;cannot&nbsp;be&nbsp;a&nbsp;lone&nbsp;dash&nbsp;and&nbsp;cannot&nbsp;contain&nbsp;spaces,<br>
newlines,&nbsp;carriage&nbsp;returns&nbsp;or&nbsp;tabs.<br>
&nbsp;<br>
*hmvc*&nbsp;and&nbsp;*fmvn*&nbsp;are&nbsp;not&nbsp;included&nbsp;by&nbsp;default.&nbsp;You&nbsp;can&nbsp;use:<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;import&nbsp;chess<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt;&nbsp;board&nbsp;=&nbsp;chess.<a href="#Board">Board</a>()<br>
&gt;&gt;&gt;&nbsp;board.<a href="#Board-epd">epd</a>(hmvc=board.halfmove_clock,&nbsp;fmvn=board.fullmove_number)<br>
'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR&nbsp;w&nbsp;KQkq&nbsp;-&nbsp;hmvc&nbsp;0;&nbsp;fmvn&nbsp;1;'</tt></dd></dl>

<dl><dt><a name="Board-fen"><strong>fen</strong></a>(self, *, shredder: 'bool' = False, en_passant: '_EnPassantSpec' = 'legal', promoted: 'Optional[bool]' = None) -&gt; 'str'</dt><dd><tt>Gets&nbsp;a&nbsp;FEN&nbsp;representation&nbsp;of&nbsp;the&nbsp;position.<br>
&nbsp;<br>
A&nbsp;FEN&nbsp;string&nbsp;(e.g.,<br>
``rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR&nbsp;w&nbsp;KQkq&nbsp;-&nbsp;0&nbsp;1``)&nbsp;consists<br>
of&nbsp;the&nbsp;board&nbsp;part&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-board_fen">board_fen</a>()`,&nbsp;the<br>
:data:`~chess.<a href="#Board">Board</a>.turn`,&nbsp;the&nbsp;castling&nbsp;part<br>
(:data:`~chess.<a href="#Board">Board</a>.castling_rights`),<br>
the&nbsp;en&nbsp;passant&nbsp;square&nbsp;(:data:`~chess.<a href="#Board">Board</a>.ep_square`),<br>
the&nbsp;:data:`~chess.<a href="#Board">Board</a>.halfmove_clock`<br>
and&nbsp;the&nbsp;:data:`~chess.<a href="#Board">Board</a>.fullmove_number`.<br>
&nbsp;<br>
:param&nbsp;shredder:&nbsp;Use&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-castling_shredder_fen">castling_shredder_fen</a>()`<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;encode&nbsp;castling&nbsp;rights&nbsp;by&nbsp;the&nbsp;file&nbsp;of&nbsp;the&nbsp;rook<br>
&nbsp;&nbsp;&nbsp;&nbsp;(like&nbsp;``HAha``)&nbsp;instead&nbsp;of&nbsp;the&nbsp;default<br>
&nbsp;&nbsp;&nbsp;&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-castling_xfen">castling_xfen</a>()`&nbsp;(like&nbsp;``KQkq``).<br>
:param&nbsp;en_passant:&nbsp;By&nbsp;default,&nbsp;only&nbsp;fully&nbsp;legal&nbsp;en&nbsp;passant&nbsp;squares<br>
&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;included&nbsp;(:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-has_legal_en_passant">has_legal_en_passant</a>()`).<br>
&nbsp;&nbsp;&nbsp;&nbsp;Pass&nbsp;``fen``&nbsp;to&nbsp;strictly&nbsp;follow&nbsp;the&nbsp;FEN&nbsp;specification<br>
&nbsp;&nbsp;&nbsp;&nbsp;(always&nbsp;include&nbsp;the&nbsp;en&nbsp;passant&nbsp;square&nbsp;after&nbsp;a&nbsp;two-step&nbsp;pawn&nbsp;move)<br>
&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;``xfen``&nbsp;to&nbsp;follow&nbsp;the&nbsp;X-FEN&nbsp;specification<br>
&nbsp;&nbsp;&nbsp;&nbsp;(:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-has_pseudo_legal_en_passant">has_pseudo_legal_en_passant</a>()`).<br>
:param&nbsp;promoted:&nbsp;Mark&nbsp;promoted&nbsp;pieces&nbsp;like&nbsp;``Q~``.&nbsp;By&nbsp;default,&nbsp;this&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;enabled&nbsp;in&nbsp;chess&nbsp;variants&nbsp;where&nbsp;this&nbsp;is&nbsp;relevant.</tt></dd></dl>

<dl><dt><a name="Board-find_move"><strong>find_move</strong></a>(self, from_square: 'Square', to_square: 'Square', promotion: 'Optional[PieceType]' = None) -&gt; 'Move'</dt><dd><tt>Finds&nbsp;a&nbsp;matching&nbsp;legal&nbsp;move&nbsp;for&nbsp;an&nbsp;origin&nbsp;square,&nbsp;a&nbsp;target&nbsp;square,&nbsp;and<br>
an&nbsp;optional&nbsp;promotion&nbsp;piece&nbsp;type.<br>
&nbsp;<br>
For&nbsp;pawn&nbsp;moves&nbsp;to&nbsp;the&nbsp;backrank,&nbsp;the&nbsp;promotion&nbsp;piece&nbsp;type&nbsp;defaults&nbsp;to<br>
:data:`chess.QUEEN`,&nbsp;unless&nbsp;otherwise&nbsp;specified.<br>
&nbsp;<br>
Castling&nbsp;moves&nbsp;are&nbsp;normalized&nbsp;to&nbsp;king&nbsp;moves&nbsp;by&nbsp;two&nbsp;steps,&nbsp;except&nbsp;in<br>
Chess960.<br>
&nbsp;<br>
:raises:&nbsp;:exc:`IllegalMoveError`&nbsp;if&nbsp;no&nbsp;matching&nbsp;legal&nbsp;move&nbsp;is&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Board-generate_castling_moves"><strong>generate_castling_moves</strong></a>(self, from_mask: 'Bitboard' = 18446744073709551615, to_mask: 'Bitboard' = 18446744073709551615) -&gt; 'Iterator[Move]'</dt></dl>

<dl><dt><a name="Board-generate_legal_captures"><strong>generate_legal_captures</strong></a>(self, from_mask: 'Bitboard' = 18446744073709551615, to_mask: 'Bitboard' = 18446744073709551615) -&gt; 'Iterator[Move]'</dt></dl>

<dl><dt><a name="Board-generate_legal_ep"><strong>generate_legal_ep</strong></a>(self, from_mask: 'Bitboard' = 18446744073709551615, to_mask: 'Bitboard' = 18446744073709551615) -&gt; 'Iterator[Move]'</dt></dl>

<dl><dt><a name="Board-generate_legal_moves"><strong>generate_legal_moves</strong></a>(self, from_mask: 'Bitboard' = 18446744073709551615, to_mask: 'Bitboard' = 18446744073709551615) -&gt; 'Iterator[Move]'</dt></dl>

<dl><dt><a name="Board-generate_pseudo_legal_captures"><strong>generate_pseudo_legal_captures</strong></a>(self, from_mask: 'Bitboard' = 18446744073709551615, to_mask: 'Bitboard' = 18446744073709551615) -&gt; 'Iterator[Move]'</dt></dl>

<dl><dt><a name="Board-generate_pseudo_legal_ep"><strong>generate_pseudo_legal_ep</strong></a>(self, from_mask: 'Bitboard' = 18446744073709551615, to_mask: 'Bitboard' = 18446744073709551615) -&gt; 'Iterator[Move]'</dt></dl>

<dl><dt><a name="Board-generate_pseudo_legal_moves"><strong>generate_pseudo_legal_moves</strong></a>(self, from_mask: 'Bitboard' = 18446744073709551615, to_mask: 'Bitboard' = 18446744073709551615) -&gt; 'Iterator[Move]'</dt></dl>

<dl><dt><a name="Board-gives_check"><strong>gives_check</strong></a>(self, move: 'Move') -&gt; 'bool'</dt><dd><tt>Probes&nbsp;if&nbsp;the&nbsp;given&nbsp;move&nbsp;would&nbsp;put&nbsp;the&nbsp;opponent&nbsp;in&nbsp;check.&nbsp;The&nbsp;move<br>
must&nbsp;be&nbsp;at&nbsp;least&nbsp;pseudo-legal.</tt></dd></dl>

<dl><dt><a name="Board-has_castling_rights"><strong>has_castling_rights</strong></a>(self, color: 'Color') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;side&nbsp;has&nbsp;castling&nbsp;rights.</tt></dd></dl>

<dl><dt><a name="Board-has_chess960_castling_rights"><strong>has_chess960_castling_rights</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;there&nbsp;are&nbsp;castling&nbsp;rights&nbsp;that&nbsp;are&nbsp;only&nbsp;possible&nbsp;in&nbsp;Chess960.</tt></dd></dl>

<dl><dt><a name="Board-has_insufficient_material"><strong>has_insufficient_material</strong></a>(self, color: 'Color') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;*color*&nbsp;has&nbsp;insufficient&nbsp;winning&nbsp;material.<br>
&nbsp;<br>
This&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;return&nbsp;``False``&nbsp;if&nbsp;*color*&nbsp;can&nbsp;still&nbsp;win&nbsp;the<br>
game.<br>
&nbsp;<br>
The&nbsp;converse&nbsp;does&nbsp;not&nbsp;necessarily&nbsp;hold:<br>
The&nbsp;implementation&nbsp;only&nbsp;looks&nbsp;at&nbsp;the&nbsp;material,&nbsp;including&nbsp;the&nbsp;colors<br>
of&nbsp;bishops,&nbsp;but&nbsp;not&nbsp;considering&nbsp;piece&nbsp;positions.&nbsp;So&nbsp;fortress<br>
positions&nbsp;or&nbsp;positions&nbsp;with&nbsp;forced&nbsp;lines&nbsp;may&nbsp;return&nbsp;``False``,&nbsp;even<br>
though&nbsp;there&nbsp;is&nbsp;no&nbsp;possible&nbsp;winning&nbsp;line.</tt></dd></dl>

<dl><dt><a name="Board-has_kingside_castling_rights"><strong>has_kingside_castling_rights</strong></a>(self, color: 'Color') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;side&nbsp;has&nbsp;kingside&nbsp;(that&nbsp;is&nbsp;h-side&nbsp;in&nbsp;Chess960)<br>
castling&nbsp;rights.</tt></dd></dl>

<dl><dt><a name="Board-has_legal_en_passant"><strong>has_legal_en_passant</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;there&nbsp;is&nbsp;a&nbsp;legal&nbsp;en&nbsp;passant&nbsp;capture.</tt></dd></dl>

<dl><dt><a name="Board-has_pseudo_legal_en_passant"><strong>has_pseudo_legal_en_passant</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;there&nbsp;is&nbsp;a&nbsp;pseudo-legal&nbsp;en&nbsp;passant&nbsp;capture.</tt></dd></dl>

<dl><dt><a name="Board-has_queenside_castling_rights"><strong>has_queenside_castling_rights</strong></a>(self, color: 'Color') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;side&nbsp;has&nbsp;queenside&nbsp;(that&nbsp;is&nbsp;a-side&nbsp;in&nbsp;Chess960)<br>
castling&nbsp;rights.</tt></dd></dl>

<dl><dt><a name="Board-is_capture"><strong>is_capture</strong></a>(self, move: 'Move') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;pseudo-legal&nbsp;move&nbsp;is&nbsp;a&nbsp;capture.</tt></dd></dl>

<dl><dt><a name="Board-is_castling"><strong>is_castling</strong></a>(self, move: 'Move') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;pseudo-legal&nbsp;move&nbsp;is&nbsp;a&nbsp;castling&nbsp;move.</tt></dd></dl>

<dl><dt><a name="Board-is_check"><strong>is_check</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Tests&nbsp;if&nbsp;the&nbsp;current&nbsp;side&nbsp;to&nbsp;move&nbsp;is&nbsp;in&nbsp;check.</tt></dd></dl>

<dl><dt><a name="Board-is_checkmate"><strong>is_checkmate</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;current&nbsp;position&nbsp;is&nbsp;a&nbsp;checkmate.</tt></dd></dl>

<dl><dt><a name="Board-is_en_passant"><strong>is_en_passant</strong></a>(self, move: 'Move') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;pseudo-legal&nbsp;move&nbsp;is&nbsp;an&nbsp;en&nbsp;passant&nbsp;capture.</tt></dd></dl>

<dl><dt><a name="Board-is_fifty_moves"><strong>is_fifty_moves</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;that&nbsp;the&nbsp;clock&nbsp;of&nbsp;halfmoves&nbsp;since&nbsp;the&nbsp;last&nbsp;capture&nbsp;or&nbsp;pawn&nbsp;move<br>
is&nbsp;greater&nbsp;or&nbsp;equal&nbsp;to&nbsp;100,&nbsp;and&nbsp;that&nbsp;no&nbsp;other&nbsp;means&nbsp;of&nbsp;ending&nbsp;the&nbsp;game<br>
(like&nbsp;checkmate)&nbsp;take&nbsp;precedence.</tt></dd></dl>

<dl><dt><a name="Board-is_fivefold_repetition"><strong>is_fivefold_repetition</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Since&nbsp;the&nbsp;1st&nbsp;of&nbsp;July&nbsp;2014&nbsp;a&nbsp;game&nbsp;is&nbsp;automatically&nbsp;drawn&nbsp;(without<br>
a&nbsp;claim&nbsp;by&nbsp;one&nbsp;of&nbsp;the&nbsp;players)&nbsp;if&nbsp;a&nbsp;position&nbsp;occurs&nbsp;for&nbsp;the&nbsp;fifth&nbsp;time.<br>
Originally&nbsp;this&nbsp;had&nbsp;to&nbsp;occur&nbsp;on&nbsp;consecutive&nbsp;alternating&nbsp;moves,&nbsp;but<br>
this&nbsp;has&nbsp;since&nbsp;been&nbsp;revised.</tt></dd></dl>

<dl><dt><a name="Board-is_game_over"><strong>is_game_over</strong></a>(self, *, claim_draw: 'bool' = False) -&gt; 'bool'</dt></dl>

<dl><dt><a name="Board-is_insufficient_material"><strong>is_insufficient_material</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;neither&nbsp;side&nbsp;has&nbsp;sufficient&nbsp;winning&nbsp;material<br>
(:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-has_insufficient_material">has_insufficient_material</a>()`).</tt></dd></dl>

<dl><dt><a name="Board-is_into_check"><strong>is_into_check</strong></a>(self, move: 'Move') -&gt; 'bool'</dt></dl>

<dl><dt><a name="Board-is_irreversible"><strong>is_irreversible</strong></a>(self, move: 'Move') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;pseudo-legal&nbsp;move&nbsp;is&nbsp;irreversible.<br>
&nbsp;<br>
In&nbsp;standard&nbsp;chess,&nbsp;pawn&nbsp;moves,&nbsp;captures,&nbsp;moves&nbsp;that&nbsp;destroy&nbsp;castling<br>
rights&nbsp;and&nbsp;moves&nbsp;that&nbsp;cede&nbsp;en&nbsp;passant&nbsp;are&nbsp;irreversible.<br>
&nbsp;<br>
This&nbsp;method&nbsp;has&nbsp;false-negatives&nbsp;with&nbsp;forced&nbsp;lines.&nbsp;For&nbsp;example,&nbsp;a&nbsp;check<br>
that&nbsp;will&nbsp;force&nbsp;the&nbsp;king&nbsp;to&nbsp;lose&nbsp;castling&nbsp;rights&nbsp;is&nbsp;not&nbsp;considered<br>
irreversible.&nbsp;Only&nbsp;the&nbsp;actual&nbsp;king&nbsp;move&nbsp;is.</tt></dd></dl>

<dl><dt><a name="Board-is_kingside_castling"><strong>is_kingside_castling</strong></a>(self, move: 'Move') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;pseudo-legal&nbsp;move&nbsp;is&nbsp;a&nbsp;kingside&nbsp;castling&nbsp;move.</tt></dd></dl>

<dl><dt><a name="Board-is_legal"><strong>is_legal</strong></a>(self, move: 'Move') -&gt; 'bool'</dt></dl>

<dl><dt><a name="Board-is_pseudo_legal"><strong>is_pseudo_legal</strong></a>(self, move: 'Move') -&gt; 'bool'</dt></dl>

<dl><dt><a name="Board-is_queenside_castling"><strong>is_queenside_castling</strong></a>(self, move: 'Move') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;pseudo-legal&nbsp;move&nbsp;is&nbsp;a&nbsp;queenside&nbsp;castling&nbsp;move.</tt></dd></dl>

<dl><dt><a name="Board-is_repetition"><strong>is_repetition</strong></a>(self, count: 'int' = 3) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;current&nbsp;position&nbsp;has&nbsp;repeated&nbsp;3&nbsp;(or&nbsp;a&nbsp;given&nbsp;number&nbsp;of)<br>
times.<br>
&nbsp;<br>
Unlike&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-can_claim_threefold_repetition">can_claim_threefold_repetition</a>()`,<br>
this&nbsp;does&nbsp;not&nbsp;consider&nbsp;a&nbsp;repetition&nbsp;that&nbsp;can&nbsp;be&nbsp;played&nbsp;on&nbsp;the&nbsp;next<br>
move.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;checking&nbsp;this&nbsp;can&nbsp;be&nbsp;slow:&nbsp;In&nbsp;the&nbsp;worst&nbsp;case,&nbsp;the&nbsp;entire<br>
game&nbsp;has&nbsp;to&nbsp;be&nbsp;replayed&nbsp;because&nbsp;there&nbsp;is&nbsp;no&nbsp;incremental&nbsp;transposition<br>
table.</tt></dd></dl>

<dl><dt><a name="Board-is_seventyfive_moves"><strong>is_seventyfive_moves</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Since&nbsp;the&nbsp;1st&nbsp;of&nbsp;July&nbsp;2014,&nbsp;a&nbsp;game&nbsp;is&nbsp;automatically&nbsp;drawn&nbsp;(without<br>
a&nbsp;claim&nbsp;by&nbsp;one&nbsp;of&nbsp;the&nbsp;players)&nbsp;if&nbsp;the&nbsp;half-move&nbsp;clock&nbsp;since&nbsp;a&nbsp;capture<br>
or&nbsp;pawn&nbsp;move&nbsp;is&nbsp;equal&nbsp;to&nbsp;or&nbsp;greater&nbsp;than&nbsp;150.&nbsp;Other&nbsp;means&nbsp;to&nbsp;end&nbsp;a&nbsp;game<br>
take&nbsp;precedence.</tt></dd></dl>

<dl><dt><a name="Board-is_stalemate"><strong>is_stalemate</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;current&nbsp;position&nbsp;is&nbsp;a&nbsp;stalemate.</tt></dd></dl>

<dl><dt><a name="Board-is_valid"><strong>is_valid</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;some&nbsp;basic&nbsp;validity&nbsp;requirements.<br>
&nbsp;<br>
See&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-status">status</a>()`&nbsp;for&nbsp;details.</tt></dd></dl>

<dl><dt><a name="Board-is_variant_draw"><strong>is_variant_draw</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;a&nbsp;variant-specific&nbsp;drawing&nbsp;condition&nbsp;is&nbsp;fulfilled.</tt></dd></dl>

<dl><dt><a name="Board-is_variant_end"><strong>is_variant_end</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;game&nbsp;is&nbsp;over&nbsp;due&nbsp;to&nbsp;a&nbsp;special&nbsp;variant&nbsp;end&nbsp;condition.<br>
&nbsp;<br>
Note,&nbsp;for&nbsp;example,&nbsp;that&nbsp;stalemate&nbsp;is&nbsp;not&nbsp;considered&nbsp;a&nbsp;variant-specific<br>
end&nbsp;condition&nbsp;(this&nbsp;method&nbsp;will&nbsp;return&nbsp;``False``),&nbsp;yet&nbsp;it&nbsp;can&nbsp;have&nbsp;a<br>
special&nbsp;**result**&nbsp;in&nbsp;suicide&nbsp;chess&nbsp;(any&nbsp;of<br>
:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-is_variant_loss">is_variant_loss</a>()`,<br>
:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-is_variant_win">is_variant_win</a>()`,<br>
:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-is_variant_draw">is_variant_draw</a>()`&nbsp;might&nbsp;return&nbsp;``True``).</tt></dd></dl>

<dl><dt><a name="Board-is_variant_loss"><strong>is_variant_loss</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;current&nbsp;side&nbsp;to&nbsp;move&nbsp;lost&nbsp;due&nbsp;to&nbsp;a&nbsp;variant-specific<br>
condition.</tt></dd></dl>

<dl><dt><a name="Board-is_variant_win"><strong>is_variant_win</strong></a>(self) -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;current&nbsp;side&nbsp;to&nbsp;move&nbsp;won&nbsp;due&nbsp;to&nbsp;a&nbsp;variant-specific<br>
condition.</tt></dd></dl>

<dl><dt><a name="Board-is_zeroing"><strong>is_zeroing</strong></a>(self, move: 'Move') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;pseudo-legal&nbsp;move&nbsp;is&nbsp;a&nbsp;capture&nbsp;or&nbsp;pawn&nbsp;move.</tt></dd></dl>

<dl><dt><a name="Board-lan"><strong>lan</strong></a>(self, move: 'Move') -&gt; 'str'</dt><dd><tt>Gets&nbsp;the&nbsp;long&nbsp;algebraic&nbsp;notation&nbsp;of&nbsp;the&nbsp;given&nbsp;move&nbsp;in&nbsp;the&nbsp;context&nbsp;of<br>
the&nbsp;current&nbsp;position.</tt></dd></dl>

<dl><dt><a name="Board-mirror"><strong>mirror</strong></a>(self: 'BoardT') -&gt; 'BoardT'</dt><dd><tt>Returns&nbsp;a&nbsp;mirrored&nbsp;copy&nbsp;of&nbsp;the&nbsp;board.<br>
&nbsp;<br>
The&nbsp;board&nbsp;is&nbsp;mirrored&nbsp;vertically&nbsp;and&nbsp;piece&nbsp;colors&nbsp;are&nbsp;swapped,&nbsp;so&nbsp;that<br>
the&nbsp;position&nbsp;is&nbsp;equivalent&nbsp;modulo&nbsp;color.&nbsp;Also&nbsp;swap&nbsp;the&nbsp;"en&nbsp;passant"<br>
square,&nbsp;castling&nbsp;rights&nbsp;and&nbsp;turn.<br>
&nbsp;<br>
Alternatively,&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-apply_mirror">apply_mirror</a>()`&nbsp;can&nbsp;be&nbsp;used<br>
to&nbsp;mirror&nbsp;the&nbsp;board.</tt></dd></dl>

<dl><dt><a name="Board-outcome"><strong>outcome</strong></a>(self, *, claim_draw: 'bool' = False) -&gt; 'Optional[Outcome]'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;game&nbsp;is&nbsp;over&nbsp;due&nbsp;to<br>
:func:`checkmate&nbsp;&lt;chess.<a href="#Board">Board</a>.<a href="#Board-is_checkmate">is_checkmate</a>()&gt;`,<br>
:func:`stalemate&nbsp;&lt;chess.<a href="#Board">Board</a>.<a href="#Board-is_stalemate">is_stalemate</a>()&gt;`,<br>
:func:`insufficient&nbsp;material&nbsp;&lt;chess.<a href="#Board">Board</a>.<a href="#Board-is_insufficient_material">is_insufficient_material</a>()&gt;`,<br>
the&nbsp;:func:`seventyfive-move&nbsp;rule&nbsp;&lt;chess.<a href="#Board">Board</a>.<a href="#Board-is_seventyfive_moves">is_seventyfive_moves</a>()&gt;`,<br>
:func:`fivefold&nbsp;repetition&nbsp;&lt;chess.<a href="#Board">Board</a>.<a href="#Board-is_fivefold_repetition">is_fivefold_repetition</a>()&gt;`,<br>
or&nbsp;a&nbsp;:func:`variant&nbsp;end&nbsp;condition&nbsp;&lt;chess.<a href="#Board">Board</a>.<a href="#Board-is_variant_end">is_variant_end</a>()&gt;`.<br>
Returns&nbsp;the&nbsp;:class:`chess.Outcome`&nbsp;if&nbsp;the&nbsp;game&nbsp;has&nbsp;ended,&nbsp;otherwise<br>
``None``.<br>
&nbsp;<br>
Alternatively,&nbsp;use&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-is_game_over">is_game_over</a>()`&nbsp;if&nbsp;you&nbsp;are&nbsp;not<br>
interested&nbsp;in&nbsp;who&nbsp;won&nbsp;the&nbsp;game&nbsp;and&nbsp;why.<br>
&nbsp;<br>
The&nbsp;game&nbsp;is&nbsp;not&nbsp;considered&nbsp;to&nbsp;be&nbsp;over&nbsp;by&nbsp;the<br>
:func:`fifty-move&nbsp;rule&nbsp;&lt;chess.<a href="#Board">Board</a>.<a href="#Board-can_claim_fifty_moves">can_claim_fifty_moves</a>()&gt;`&nbsp;or<br>
:func:`threefold&nbsp;repetition&nbsp;&lt;chess.<a href="#Board">Board</a>.<a href="#Board-can_claim_threefold_repetition">can_claim_threefold_repetition</a>()&gt;`,<br>
unless&nbsp;*claim_draw*&nbsp;is&nbsp;given.&nbsp;Note&nbsp;that&nbsp;checking&nbsp;the&nbsp;latter&nbsp;can&nbsp;be<br>
slow.</tt></dd></dl>

<dl><dt><a name="Board-parse_san"><strong>parse_san</strong></a>(self, san: 'str') -&gt; 'Move'</dt><dd><tt>Uses&nbsp;the&nbsp;current&nbsp;position&nbsp;as&nbsp;the&nbsp;context&nbsp;to&nbsp;parse&nbsp;a&nbsp;move&nbsp;in&nbsp;standard<br>
algebraic&nbsp;notation&nbsp;and&nbsp;returns&nbsp;the&nbsp;corresponding&nbsp;move&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
Ambiguous&nbsp;moves&nbsp;are&nbsp;rejected.&nbsp;Overspecified&nbsp;moves&nbsp;(including&nbsp;long<br>
algebraic&nbsp;notation)&nbsp;are&nbsp;accepted.&nbsp;Some&nbsp;common&nbsp;syntactical&nbsp;deviations<br>
are&nbsp;also&nbsp;accepted.<br>
&nbsp;<br>
The&nbsp;returned&nbsp;move&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;either&nbsp;legal&nbsp;or&nbsp;a&nbsp;null&nbsp;move.<br>
&nbsp;<br>
:raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;:exc:`ValueError`&nbsp;(specifically&nbsp;an&nbsp;exception&nbsp;specified&nbsp;below)&nbsp;if&nbsp;the&nbsp;SAN&nbsp;is&nbsp;invalid,&nbsp;illegal&nbsp;or&nbsp;ambiguous.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:exc:`InvalidMoveError`&nbsp;if&nbsp;the&nbsp;SAN&nbsp;is&nbsp;syntactically&nbsp;invalid.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:exc:`IllegalMoveError`&nbsp;if&nbsp;the&nbsp;SAN&nbsp;is&nbsp;illegal.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:exc:`AmbiguousMoveError`&nbsp;if&nbsp;the&nbsp;SAN&nbsp;is&nbsp;ambiguous.</tt></dd></dl>

<dl><dt><a name="Board-parse_uci"><strong>parse_uci</strong></a>(self, uci: 'str') -&gt; 'Move'</dt><dd><tt>Parses&nbsp;the&nbsp;given&nbsp;move&nbsp;in&nbsp;UCI&nbsp;notation.<br>
&nbsp;<br>
Supports&nbsp;both&nbsp;Chess960&nbsp;and&nbsp;standard&nbsp;UCI&nbsp;notation.<br>
&nbsp;<br>
The&nbsp;returned&nbsp;move&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;either&nbsp;legal&nbsp;or&nbsp;a&nbsp;null&nbsp;move.<br>
&nbsp;<br>
:raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;:exc:`ValueError`&nbsp;(specifically&nbsp;an&nbsp;exception&nbsp;specified&nbsp;below)&nbsp;if&nbsp;the&nbsp;move&nbsp;is&nbsp;invalid&nbsp;or&nbsp;illegal&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;position&nbsp;(but&nbsp;not&nbsp;a&nbsp;null&nbsp;move).<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:exc:`InvalidMoveError`&nbsp;if&nbsp;the&nbsp;UCI&nbsp;is&nbsp;syntactically&nbsp;invalid.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:exc:`IllegalMoveError`&nbsp;if&nbsp;the&nbsp;UCI&nbsp;is&nbsp;illegal.</tt></dd></dl>

<dl><dt><a name="Board-parse_xboard"><strong>parse_xboard</strong></a>(self, xboard: 'str') -&gt; 'Move'</dt></dl>

<dl><dt><a name="Board-peek"><strong>peek</strong></a>(self) -&gt; 'Move'</dt><dd><tt>Gets&nbsp;the&nbsp;last&nbsp;move&nbsp;from&nbsp;the&nbsp;move&nbsp;stack.<br>
&nbsp;<br>
:raises:&nbsp;:exc:`IndexError`&nbsp;if&nbsp;the&nbsp;move&nbsp;stack&nbsp;is&nbsp;empty.</tt></dd></dl>

<dl><dt><a name="Board-ply"><strong>ply</strong></a>(self) -&gt; 'int'</dt><dd><tt>Returns&nbsp;the&nbsp;number&nbsp;of&nbsp;half-moves&nbsp;since&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;game,&nbsp;as<br>
indicated&nbsp;by&nbsp;:data:`~chess.<a href="#Board">Board</a>.fullmove_number`&nbsp;and<br>
:data:`~chess.<a href="#Board">Board</a>.turn`.<br>
&nbsp;<br>
If&nbsp;moves&nbsp;have&nbsp;been&nbsp;pushed&nbsp;from&nbsp;the&nbsp;beginning,&nbsp;this&nbsp;is&nbsp;usually&nbsp;equal&nbsp;to<br>
``len(board.move_stack)``.&nbsp;But&nbsp;note&nbsp;that&nbsp;a&nbsp;board&nbsp;can&nbsp;be&nbsp;set&nbsp;up&nbsp;with<br>
arbitrary&nbsp;starting&nbsp;positions,&nbsp;and&nbsp;the&nbsp;stack&nbsp;can&nbsp;be&nbsp;cleared.</tt></dd></dl>

<dl><dt><a name="Board-pop"><strong>pop</strong></a>(self: 'BoardT') -&gt; 'Move'</dt><dd><tt>Restores&nbsp;the&nbsp;previous&nbsp;position&nbsp;and&nbsp;returns&nbsp;the&nbsp;last&nbsp;move&nbsp;from&nbsp;the&nbsp;stack.<br>
&nbsp;<br>
:raises:&nbsp;:exc:`IndexError`&nbsp;if&nbsp;the&nbsp;move&nbsp;stack&nbsp;is&nbsp;empty.</tt></dd></dl>

<dl><dt><a name="Board-push"><strong>push</strong></a>(self: 'BoardT', move: 'Move') -&gt; 'None'</dt><dd><tt>Updates&nbsp;the&nbsp;position&nbsp;with&nbsp;the&nbsp;given&nbsp;*move*&nbsp;and&nbsp;puts&nbsp;it&nbsp;onto&nbsp;the<br>
move&nbsp;stack.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;import&nbsp;chess<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt;&nbsp;board&nbsp;=&nbsp;chess.<a href="#Board">Board</a>()<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt;&nbsp;Nf3&nbsp;=&nbsp;chess.<a href="#Move">Move</a>.from_uci("g1f3")<br>
&gt;&gt;&gt;&nbsp;board.<a href="#Board-push">push</a>(Nf3)&nbsp;&nbsp;#&nbsp;Make&nbsp;the&nbsp;move<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;board.<a href="#Board-pop">pop</a>()&nbsp;&nbsp;#&nbsp;Unmake&nbsp;the&nbsp;last&nbsp;move<br>
<a href="#Move">Move</a>.from_uci('g1f3')<br>
&nbsp;<br>
Null&nbsp;moves&nbsp;just&nbsp;increment&nbsp;the&nbsp;move&nbsp;counters,&nbsp;switch&nbsp;turns&nbsp;and&nbsp;forfeit<br>
en&nbsp;passant&nbsp;capturing.<br>
&nbsp;<br>
..&nbsp;warning::<br>
&nbsp;&nbsp;&nbsp;&nbsp;Moves&nbsp;are&nbsp;not&nbsp;checked&nbsp;for&nbsp;legality.&nbsp;It&nbsp;is&nbsp;the&nbsp;caller's<br>
&nbsp;&nbsp;&nbsp;&nbsp;responsibility&nbsp;to&nbsp;ensure&nbsp;that&nbsp;the&nbsp;move&nbsp;is&nbsp;at&nbsp;least&nbsp;pseudo-legal&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;null&nbsp;move.</tt></dd></dl>

<dl><dt><a name="Board-push_san"><strong>push_san</strong></a>(self, san: 'str') -&gt; 'Move'</dt><dd><tt>Parses&nbsp;a&nbsp;move&nbsp;in&nbsp;standard&nbsp;algebraic&nbsp;notation,&nbsp;makes&nbsp;the&nbsp;move&nbsp;and&nbsp;puts<br>
it&nbsp;onto&nbsp;the&nbsp;move&nbsp;stack.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;move.<br>
&nbsp;<br>
:raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;:exc:`ValueError`&nbsp;(specifically&nbsp;an&nbsp;exception&nbsp;specified&nbsp;below)&nbsp;if&nbsp;neither&nbsp;legal&nbsp;nor&nbsp;a&nbsp;null&nbsp;move.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:exc:`InvalidMoveError`&nbsp;if&nbsp;the&nbsp;SAN&nbsp;is&nbsp;syntactically&nbsp;invalid.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:exc:`IllegalMoveError`&nbsp;if&nbsp;the&nbsp;SAN&nbsp;is&nbsp;illegal.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:exc:`AmbiguousMoveError`&nbsp;if&nbsp;the&nbsp;SAN&nbsp;is&nbsp;ambiguous.</tt></dd></dl>

<dl><dt><a name="Board-push_uci"><strong>push_uci</strong></a>(self, uci: 'str') -&gt; 'Move'</dt><dd><tt>Parses&nbsp;a&nbsp;move&nbsp;in&nbsp;UCI&nbsp;notation&nbsp;and&nbsp;puts&nbsp;it&nbsp;on&nbsp;the&nbsp;move&nbsp;stack.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;move.<br>
&nbsp;<br>
:raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;:exc:`ValueError`&nbsp;(specifically&nbsp;an&nbsp;exception&nbsp;specified&nbsp;below)&nbsp;if&nbsp;the&nbsp;move&nbsp;is&nbsp;invalid&nbsp;or&nbsp;illegal&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;position&nbsp;(but&nbsp;not&nbsp;a&nbsp;null&nbsp;move).<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:exc:`InvalidMoveError`&nbsp;if&nbsp;the&nbsp;UCI&nbsp;is&nbsp;syntactically&nbsp;invalid.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:exc:`IllegalMoveError`&nbsp;if&nbsp;the&nbsp;UCI&nbsp;is&nbsp;illegal.</tt></dd></dl>

<dl><dt><a name="Board-push_xboard"><strong>push_xboard</strong></a> = <a href="#Board-push_san">push_san</a>(self, san: 'str') -&gt; 'Move'</dt></dl>

<dl><dt><a name="Board-remove_piece_at"><strong>remove_piece_at</strong></a>(self, square: 'Square') -&gt; 'Optional[Piece]'</dt><dd><tt>Removes&nbsp;the&nbsp;piece&nbsp;from&nbsp;the&nbsp;given&nbsp;square.&nbsp;Returns&nbsp;the<br>
:class:`~chess.Piece`&nbsp;or&nbsp;``None``&nbsp;if&nbsp;the&nbsp;square&nbsp;was&nbsp;already&nbsp;empty.<br>
&nbsp;<br>
:class:`~chess.<a href="#Board">Board</a>`&nbsp;also&nbsp;clears&nbsp;the&nbsp;move&nbsp;stack.</tt></dd></dl>

<dl><dt><a name="Board-reset"><strong>reset</strong></a>(self) -&gt; 'None'</dt><dd><tt>Restores&nbsp;the&nbsp;starting&nbsp;position.</tt></dd></dl>

<dl><dt><a name="Board-reset_board"><strong>reset_board</strong></a>(self) -&gt; 'None'</dt><dd><tt>Resets&nbsp;pieces&nbsp;to&nbsp;the&nbsp;starting&nbsp;position.<br>
&nbsp;<br>
:class:`~chess.<a href="#Board">Board</a>`&nbsp;also&nbsp;resets&nbsp;the&nbsp;move&nbsp;stack,&nbsp;but&nbsp;not&nbsp;turn,<br>
castling&nbsp;rights&nbsp;and&nbsp;move&nbsp;counters.&nbsp;Use&nbsp;:func:`chess.<a href="#Board">Board</a>.<a href="#Board-reset">reset</a>()`&nbsp;to<br>
fully&nbsp;restore&nbsp;the&nbsp;starting&nbsp;position.</tt></dd></dl>

<dl><dt><a name="Board-result"><strong>result</strong></a>(self, *, claim_draw: 'bool' = False) -&gt; 'str'</dt></dl>

<dl><dt><a name="Board-root"><strong>root</strong></a>(self: 'BoardT') -&gt; 'BoardT'</dt><dd><tt>Returns&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;root&nbsp;position.</tt></dd></dl>

<dl><dt><a name="Board-san"><strong>san</strong></a>(self, move: 'Move') -&gt; 'str'</dt><dd><tt>Gets&nbsp;the&nbsp;standard&nbsp;algebraic&nbsp;notation&nbsp;of&nbsp;the&nbsp;given&nbsp;move&nbsp;in&nbsp;the&nbsp;context<br>
of&nbsp;the&nbsp;current&nbsp;position.</tt></dd></dl>

<dl><dt><a name="Board-san_and_push"><strong>san_and_push</strong></a>(self, move: 'Move') -&gt; 'str'</dt></dl>

<dl><dt><a name="Board-set_board_fen"><strong>set_board_fen</strong></a>(self, fen: 'str') -&gt; 'None'</dt><dd><tt>Parses&nbsp;*fen*&nbsp;and&nbsp;sets&nbsp;up&nbsp;the&nbsp;board,&nbsp;where&nbsp;*fen*&nbsp;is&nbsp;the&nbsp;board&nbsp;part&nbsp;of<br>
a&nbsp;FEN.<br>
&nbsp;<br>
:class:`~chess.<a href="#Board">Board</a>`&nbsp;also&nbsp;clears&nbsp;the&nbsp;move&nbsp;stack.<br>
&nbsp;<br>
:raises:&nbsp;:exc:`ValueError`&nbsp;if&nbsp;syntactically&nbsp;invalid.</tt></dd></dl>

<dl><dt><a name="Board-set_castling_fen"><strong>set_castling_fen</strong></a>(self, castling_fen: 'str') -&gt; 'None'</dt><dd><tt>Sets&nbsp;castling&nbsp;rights&nbsp;from&nbsp;a&nbsp;string&nbsp;in&nbsp;FEN&nbsp;notation&nbsp;like&nbsp;``Qqk``.<br>
&nbsp;<br>
Also&nbsp;clears&nbsp;the&nbsp;move&nbsp;stack.<br>
&nbsp;<br>
:raises:&nbsp;:exc:`ValueError`&nbsp;if&nbsp;the&nbsp;castling&nbsp;FEN&nbsp;is&nbsp;syntactically<br>
&nbsp;&nbsp;&nbsp;&nbsp;invalid.</tt></dd></dl>

<dl><dt><a name="Board-set_chess960_pos"><strong>set_chess960_pos</strong></a>(self, scharnagl: 'int') -&gt; 'None'</dt><dd><tt>Sets&nbsp;up&nbsp;a&nbsp;Chess960&nbsp;starting&nbsp;position&nbsp;given&nbsp;its&nbsp;index&nbsp;between&nbsp;0&nbsp;and&nbsp;959.<br>
Also&nbsp;see&nbsp;:func:`~chess.BaseBoard.<a href="#Board-from_chess960_pos">from_chess960_pos</a>()`.</tt></dd></dl>

<dl><dt><a name="Board-set_epd"><strong>set_epd</strong></a>(self, epd: 'str') -&gt; 'Dict[str, Union[None, str, int, float, Move, List[Move]]]'</dt><dd><tt>Parses&nbsp;the&nbsp;given&nbsp;EPD&nbsp;string&nbsp;and&nbsp;uses&nbsp;it&nbsp;to&nbsp;set&nbsp;the&nbsp;position.<br>
&nbsp;<br>
If&nbsp;present,&nbsp;``hmvc``&nbsp;and&nbsp;``fmvn``&nbsp;are&nbsp;used&nbsp;to&nbsp;set&nbsp;the&nbsp;half-move<br>
clock&nbsp;and&nbsp;the&nbsp;full-move&nbsp;number.&nbsp;Otherwise,&nbsp;``0``&nbsp;and&nbsp;``1``&nbsp;are&nbsp;used.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;dictionary&nbsp;of&nbsp;parsed&nbsp;operations.&nbsp;Values&nbsp;can&nbsp;be&nbsp;strings,<br>
integers,&nbsp;floats,&nbsp;move&nbsp;objects,&nbsp;or&nbsp;lists&nbsp;of&nbsp;moves.<br>
&nbsp;<br>
:raises:&nbsp;:exc:`ValueError`&nbsp;if&nbsp;the&nbsp;EPD&nbsp;string&nbsp;is&nbsp;invalid.</tt></dd></dl>

<dl><dt><a name="Board-set_fen"><strong>set_fen</strong></a>(self, fen: 'str') -&gt; 'None'</dt><dd><tt>Parses&nbsp;a&nbsp;FEN&nbsp;and&nbsp;sets&nbsp;the&nbsp;position&nbsp;from&nbsp;it.<br>
&nbsp;<br>
:raises:&nbsp;:exc:`ValueError`&nbsp;if&nbsp;syntactically&nbsp;invalid.&nbsp;Use<br>
&nbsp;&nbsp;&nbsp;&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-is_valid">is_valid</a>()`&nbsp;to&nbsp;detect&nbsp;invalid&nbsp;positions.</tt></dd></dl>

<dl><dt><a name="Board-set_piece_at"><strong>set_piece_at</strong></a>(self, square: 'Square', piece: 'Optional[Piece]', promoted: 'bool' = False) -&gt; 'None'</dt><dd><tt>Sets&nbsp;a&nbsp;piece&nbsp;at&nbsp;the&nbsp;given&nbsp;square.<br>
&nbsp;<br>
An&nbsp;existing&nbsp;piece&nbsp;is&nbsp;replaced.&nbsp;Setting&nbsp;*piece*&nbsp;to&nbsp;``None``&nbsp;is<br>
equivalent&nbsp;to&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-remove_piece_at">remove_piece_at</a>()`.<br>
&nbsp;<br>
:class:`~chess.<a href="#Board">Board</a>`&nbsp;also&nbsp;clears&nbsp;the&nbsp;move&nbsp;stack.</tt></dd></dl>

<dl><dt><a name="Board-set_piece_map"><strong>set_piece_map</strong></a>(self, pieces: 'Mapping[Square, Piece]') -&gt; 'None'</dt><dd><tt>Sets&nbsp;up&nbsp;the&nbsp;board&nbsp;from&nbsp;a&nbsp;dictionary&nbsp;of&nbsp;:class:`pieces&nbsp;&lt;chess.Piece&gt;`<br>
by&nbsp;square&nbsp;index.<br>
&nbsp;<br>
:class:`~chess.<a href="#Board">Board</a>`&nbsp;also&nbsp;clears&nbsp;the&nbsp;move&nbsp;stack.</tt></dd></dl>

<dl><dt><a name="Board-shredder_fen"><strong>shredder_fen</strong></a>(self, *, en_passant: '_EnPassantSpec' = 'legal', promoted: 'Optional[bool]' = None) -&gt; 'str'</dt></dl>

<dl><dt><a name="Board-status"><strong>status</strong></a>(self) -&gt; 'Status'</dt><dd><tt>Gets&nbsp;a&nbsp;bitmask&nbsp;of&nbsp;possible&nbsp;problems&nbsp;with&nbsp;the&nbsp;position.<br>
&nbsp;<br>
:data:`~chess.STATUS_VALID`&nbsp;if&nbsp;all&nbsp;basic&nbsp;validity&nbsp;requirements&nbsp;are&nbsp;met.<br>
This&nbsp;does&nbsp;not&nbsp;imply&nbsp;that&nbsp;the&nbsp;position&nbsp;is&nbsp;actually&nbsp;reachable&nbsp;with&nbsp;a<br>
series&nbsp;of&nbsp;legal&nbsp;moves&nbsp;from&nbsp;the&nbsp;starting&nbsp;position.<br>
&nbsp;<br>
Otherwise,&nbsp;bitwise&nbsp;combinations&nbsp;of:<br>
:data:`~chess.STATUS_NO_WHITE_KING`,<br>
:data:`~chess.STATUS_NO_BLACK_KING`,<br>
:data:`~chess.STATUS_TOO_MANY_KINGS`,<br>
:data:`~chess.STATUS_TOO_MANY_WHITE_PAWNS`,<br>
:data:`~chess.STATUS_TOO_MANY_BLACK_PAWNS`,<br>
:data:`~chess.STATUS_PAWNS_ON_BACKRANK`,<br>
:data:`~chess.STATUS_TOO_MANY_WHITE_PIECES`,<br>
:data:`~chess.STATUS_TOO_MANY_BLACK_PIECES`,<br>
:data:`~chess.STATUS_BAD_CASTLING_RIGHTS`,<br>
:data:`~chess.STATUS_INVALID_EP_SQUARE`,<br>
:data:`~chess.STATUS_OPPOSITE_CHECK`,<br>
:data:`~chess.STATUS_EMPTY`,<br>
:data:`~chess.STATUS_RACE_CHECK`,<br>
:data:`~chess.STATUS_RACE_OVER`,<br>
:data:`~chess.STATUS_RACE_MATERIAL`,<br>
:data:`~chess.STATUS_TOO_MANY_CHECKERS`,<br>
:data:`~chess.STATUS_IMPOSSIBLE_CHECK`.</tt></dd></dl>

<dl><dt><a name="Board-transform"><strong>transform</strong></a>(self: 'BoardT', f: 'Callable[[Bitboard], Bitboard]') -&gt; 'BoardT'</dt><dd><tt>Returns&nbsp;a&nbsp;transformed&nbsp;copy&nbsp;of&nbsp;the&nbsp;board&nbsp;(without&nbsp;move&nbsp;stack)<br>
by&nbsp;applying&nbsp;a&nbsp;bitboard&nbsp;transformation&nbsp;function.<br>
&nbsp;<br>
Available&nbsp;transformations&nbsp;include&nbsp;:func:`chess.flip_vertical()`,<br>
:func:`chess.flip_horizontal()`,&nbsp;:func:`chess.flip_diagonal()`,<br>
:func:`chess.flip_anti_diagonal()`,&nbsp;:func:`chess.shift_down()`,<br>
:func:`chess.shift_up()`,&nbsp;:func:`chess.shift_left()`,&nbsp;and<br>
:func:`chess.shift_right()`.<br>
&nbsp;<br>
Alternatively,&nbsp;:func:`~chess.BaseBoard.<a href="#Board-apply_transform">apply_transform</a>()`&nbsp;can&nbsp;be&nbsp;used<br>
to&nbsp;apply&nbsp;the&nbsp;transformation&nbsp;on&nbsp;the&nbsp;board.</tt></dd></dl>

<dl><dt><a name="Board-uci"><strong>uci</strong></a>(self, move: 'Move', *, chess960: 'Optional[bool]' = None) -&gt; 'str'</dt><dd><tt>Gets&nbsp;the&nbsp;UCI&nbsp;notation&nbsp;of&nbsp;the&nbsp;move.<br>
&nbsp;<br>
*chess960*&nbsp;defaults&nbsp;to&nbsp;the&nbsp;mode&nbsp;of&nbsp;the&nbsp;board.&nbsp;Pass&nbsp;``True``&nbsp;to&nbsp;force<br>
Chess960&nbsp;mode.</tt></dd></dl>

<dl><dt><a name="Board-variation_san"><strong>variation_san</strong></a>(self, variation: 'Iterable[Move]') -&gt; 'str'</dt><dd><tt>Given&nbsp;a&nbsp;sequence&nbsp;of&nbsp;moves,&nbsp;returns&nbsp;a&nbsp;string&nbsp;representing&nbsp;the&nbsp;sequence<br>
in&nbsp;standard&nbsp;algebraic&nbsp;notation&nbsp;(e.g.,&nbsp;``1.&nbsp;e4&nbsp;e5&nbsp;2.&nbsp;Nf3&nbsp;Nc6``&nbsp;or<br>
``37...Bg6&nbsp;38.&nbsp;fxg6``).<br>
&nbsp;<br>
The&nbsp;board&nbsp;will&nbsp;not&nbsp;be&nbsp;modified&nbsp;as&nbsp;a&nbsp;result&nbsp;of&nbsp;calling&nbsp;this.<br>
&nbsp;<br>
:raises:&nbsp;:exc:`IllegalMoveError`&nbsp;if&nbsp;any&nbsp;moves&nbsp;in&nbsp;the&nbsp;sequence&nbsp;are&nbsp;illegal.</tt></dd></dl>

<dl><dt><a name="Board-was_into_check"><strong>was_into_check</strong></a>(self) -&gt; 'bool'</dt></dl>

<dl><dt><a name="Board-xboard"><strong>xboard</strong></a>(self, move: 'Move', chess960: 'Optional[bool]' = None) -&gt; 'str'</dt></dl>

<hr>
Class methods inherited from <a href="chess.html#Board">chess.Board</a>:<br>
<dl><dt><a name="Board-empty"><strong>empty</strong></a>(*, chess960: 'bool' = False) -&gt; 'BoardT'<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Creates&nbsp;a&nbsp;new&nbsp;empty&nbsp;board.&nbsp;Also&nbsp;see&nbsp;:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-clear">clear</a>()`.</tt></dd></dl>

<dl><dt><a name="Board-from_chess960_pos"><strong>from_chess960_pos</strong></a>(scharnagl: 'int') -&gt; 'BoardT'<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Creates&nbsp;a&nbsp;new&nbsp;board,&nbsp;initialized&nbsp;with&nbsp;a&nbsp;Chess960&nbsp;starting&nbsp;position.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;import&nbsp;chess<br>
&gt;&gt;&gt;&nbsp;import&nbsp;random<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt;&nbsp;board&nbsp;=&nbsp;chess.<a href="#Board">Board</a>.<a href="#Board-from_chess960_pos">from_chess960_pos</a>(random.randint(0,&nbsp;959))</tt></dd></dl>

<dl><dt><a name="Board-from_epd"><strong>from_epd</strong></a>(epd: 'str', *, chess960: 'bool' = False) -&gt; 'Tuple[BoardT, Dict[str, Union[None, str, int, float, Move, List[Move]]]]'<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Creates&nbsp;a&nbsp;new&nbsp;board&nbsp;from&nbsp;an&nbsp;EPD&nbsp;string.&nbsp;See<br>
:func:`~chess.<a href="#Board">Board</a>.<a href="#Board-set_epd">set_epd</a>()`.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;board&nbsp;and&nbsp;the&nbsp;dictionary&nbsp;of&nbsp;parsed&nbsp;operations&nbsp;as&nbsp;a&nbsp;tuple.</tt></dd></dl>

<hr>
Readonly properties inherited from <a href="chess.html#Board">chess.Board</a>:<br>
<dl><dt><strong>legal_moves</strong></dt>
<dd><tt>A&nbsp;dynamic&nbsp;list&nbsp;of&nbsp;legal&nbsp;moves.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;import&nbsp;chess<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt;&nbsp;board&nbsp;=&nbsp;chess.Board()<br>
&gt;&gt;&gt;&nbsp;board.legal_moves.count()<br>
20<br>
&gt;&gt;&gt;&nbsp;bool(board.legal_moves)<br>
True<br>
&gt;&gt;&gt;&nbsp;move&nbsp;=&nbsp;chess.Move.from_uci("g1f3")<br>
&gt;&gt;&gt;&nbsp;move&nbsp;in&nbsp;board.legal_moves<br>
True<br>
&nbsp;<br>
Wraps&nbsp;:func:`~chess.Board.generate_legal_moves()`&nbsp;and<br>
:func:`~chess.Board.is_legal()`.</tt></dd>
</dl>
<dl><dt><strong>pseudo_legal_moves</strong></dt>
<dd><tt>A&nbsp;dynamic&nbsp;list&nbsp;of&nbsp;pseudo-legal&nbsp;moves,&nbsp;much&nbsp;like&nbsp;the&nbsp;legal&nbsp;move&nbsp;list.<br>
&nbsp;<br>
Pseudo-legal&nbsp;moves&nbsp;might&nbsp;leave&nbsp;or&nbsp;put&nbsp;the&nbsp;king&nbsp;in&nbsp;check,&nbsp;but&nbsp;are<br>
otherwise&nbsp;valid.&nbsp;Null&nbsp;moves&nbsp;are&nbsp;not&nbsp;pseudo-legal.&nbsp;Castling&nbsp;moves&nbsp;are<br>
only&nbsp;included&nbsp;if&nbsp;they&nbsp;are&nbsp;completely&nbsp;legal.<br>
&nbsp;<br>
Wraps&nbsp;:func:`~chess.Board.generate_pseudo_legal_moves()`&nbsp;and<br>
:func:`~chess.Board.is_pseudo_legal()`.</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="chess.html#Board">chess.Board</a>:<br>
<dl><dt><strong>__hash__</strong> = None</dl>

<dl><dt><strong>aliases</strong> = ['Standard', 'Chess', 'Classical', 'Normal', 'Illegal', 'From Position']</dl>

<dl><dt><strong>captures_compulsory</strong> = False</dl>

<dl><dt><strong>connected_kings</strong> = False</dl>

<dl><dt><strong>one_king</strong> = True</dl>

<dl><dt><strong>pawnless_tbw_magic</strong> = None</dl>

<dl><dt><strong>pawnless_tbw_suffix</strong> = None</dl>

<dl><dt><strong>pawnless_tbz_magic</strong> = None</dl>

<dl><dt><strong>pawnless_tbz_suffix</strong> = None</dl>

<dl><dt><strong>starting_fen</strong> = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'</dl>

<dl><dt><strong>tbw_magic</strong> = b'q\xe8#]'</dl>

<dl><dt><strong>tbw_suffix</strong> = '.rtbw'</dl>

<dl><dt><strong>tbz_magic</strong> = b'\xd7f\x0c\xa5'</dl>

<dl><dt><strong>tbz_suffix</strong> = '.rtbz'</dl>

<dl><dt><strong>uci_variant</strong> = 'chess'</dl>

<dl><dt><strong>xboard_variant</strong> = 'normal'</dl>

<hr>
Methods inherited from <a href="chess.html#BaseBoard">chess.BaseBoard</a>:<br>
<dl><dt><a name="Board-__copy__"><strong>__copy__</strong></a>(self: 'BaseBoardT') -&gt; 'BaseBoardT'</dt></dl>

<dl><dt><a name="Board-__deepcopy__"><strong>__deepcopy__</strong></a>(self: 'BaseBoardT', memo: 'Dict[int, object]') -&gt; 'BaseBoardT'</dt></dl>

<dl><dt><a name="Board-__str__"><strong>__str__</strong></a>(self) -&gt; 'str'</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="Board-attackers"><strong>attackers</strong></a>(self, color: 'Color', square: 'Square') -&gt; 'SquareSet'</dt><dd><tt>Gets&nbsp;the&nbsp;set&nbsp;of&nbsp;attackers&nbsp;of&nbsp;the&nbsp;given&nbsp;color&nbsp;for&nbsp;the&nbsp;given&nbsp;square.<br>
&nbsp;<br>
Pinned&nbsp;pieces&nbsp;still&nbsp;count&nbsp;as&nbsp;attackers.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;:class:`set&nbsp;of&nbsp;squares&nbsp;&lt;chess.SquareSet&gt;`.</tt></dd></dl>

<dl><dt><a name="Board-attackers_mask"><strong>attackers_mask</strong></a>(self, color: 'Color', square: 'Square') -&gt; 'Bitboard'</dt></dl>

<dl><dt><a name="Board-attacks"><strong>attacks</strong></a>(self, square: 'Square') -&gt; 'SquareSet'</dt><dd><tt>Gets&nbsp;the&nbsp;set&nbsp;of&nbsp;attacked&nbsp;squares&nbsp;from&nbsp;the&nbsp;given&nbsp;square.<br>
&nbsp;<br>
There&nbsp;will&nbsp;be&nbsp;no&nbsp;attacks&nbsp;if&nbsp;the&nbsp;square&nbsp;is&nbsp;empty.&nbsp;Pinned&nbsp;pieces&nbsp;are<br>
still&nbsp;attacking&nbsp;other&nbsp;squares.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;:class:`set&nbsp;of&nbsp;squares&nbsp;&lt;chess.SquareSet&gt;`.</tt></dd></dl>

<dl><dt><a name="Board-attacks_mask"><strong>attacks_mask</strong></a>(self, square: 'Square') -&gt; 'Bitboard'</dt></dl>

<dl><dt><a name="Board-board_fen"><strong>board_fen</strong></a>(self, *, promoted: 'Optional[bool]' = False) -&gt; 'str'</dt><dd><tt>Gets&nbsp;the&nbsp;board&nbsp;FEN&nbsp;(e.g.,<br>
``rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR``).</tt></dd></dl>

<dl><dt><a name="Board-color_at"><strong>color_at</strong></a>(self, square: 'Square') -&gt; 'Optional[Color]'</dt><dd><tt>Gets&nbsp;the&nbsp;color&nbsp;of&nbsp;the&nbsp;piece&nbsp;at&nbsp;the&nbsp;given&nbsp;square.</tt></dd></dl>

<dl><dt><a name="Board-is_attacked_by"><strong>is_attacked_by</strong></a>(self, color: 'Color', square: 'Square') -&gt; 'bool'</dt><dd><tt>Checks&nbsp;if&nbsp;the&nbsp;given&nbsp;side&nbsp;attacks&nbsp;the&nbsp;given&nbsp;square.<br>
&nbsp;<br>
Pinned&nbsp;pieces&nbsp;still&nbsp;count&nbsp;as&nbsp;attackers.&nbsp;Pawns&nbsp;that&nbsp;can&nbsp;be&nbsp;captured<br>
en&nbsp;passant&nbsp;are&nbsp;**not**&nbsp;considered&nbsp;attacked.</tt></dd></dl>

<dl><dt><a name="Board-is_pinned"><strong>is_pinned</strong></a>(self, color: 'Color', square: 'Square') -&gt; 'bool'</dt><dd><tt>Detects&nbsp;if&nbsp;the&nbsp;given&nbsp;square&nbsp;is&nbsp;pinned&nbsp;to&nbsp;the&nbsp;king&nbsp;of&nbsp;the&nbsp;given&nbsp;color.</tt></dd></dl>

<dl><dt><a name="Board-king"><strong>king</strong></a>(self, color: 'Color') -&gt; 'Optional[Square]'</dt><dd><tt>Finds&nbsp;the&nbsp;king&nbsp;square&nbsp;of&nbsp;the&nbsp;given&nbsp;side.&nbsp;Returns&nbsp;``None``&nbsp;if&nbsp;there<br>
is&nbsp;no&nbsp;king&nbsp;of&nbsp;that&nbsp;color.<br>
&nbsp;<br>
In&nbsp;variants&nbsp;with&nbsp;king&nbsp;promotions,&nbsp;only&nbsp;non-promoted&nbsp;kings&nbsp;are<br>
considered.</tt></dd></dl>

<dl><dt><a name="Board-piece_at"><strong>piece_at</strong></a>(self, square: 'Square') -&gt; 'Optional[Piece]'</dt><dd><tt>Gets&nbsp;the&nbsp;:class:`piece&nbsp;&lt;chess.Piece&gt;`&nbsp;at&nbsp;the&nbsp;given&nbsp;square.</tt></dd></dl>

<dl><dt><a name="Board-piece_map"><strong>piece_map</strong></a>(self, *, mask: 'Bitboard' = 18446744073709551615) -&gt; 'Dict[Square, Piece]'</dt><dd><tt>Gets&nbsp;a&nbsp;dictionary&nbsp;of&nbsp;:class:`pieces&nbsp;&lt;chess.Piece&gt;`&nbsp;by&nbsp;square&nbsp;index.</tt></dd></dl>

<dl><dt><a name="Board-piece_type_at"><strong>piece_type_at</strong></a>(self, square: 'Square') -&gt; 'Optional[PieceType]'</dt><dd><tt>Gets&nbsp;the&nbsp;piece&nbsp;type&nbsp;at&nbsp;the&nbsp;given&nbsp;square.</tt></dd></dl>

<dl><dt><a name="Board-pieces"><strong>pieces</strong></a>(self, piece_type: 'PieceType', color: 'Color') -&gt; 'SquareSet'</dt><dd><tt>Gets&nbsp;pieces&nbsp;of&nbsp;the&nbsp;given&nbsp;type&nbsp;and&nbsp;color.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;:class:`set&nbsp;of&nbsp;squares&nbsp;&lt;chess.SquareSet&gt;`.</tt></dd></dl>

<dl><dt><a name="Board-pieces_mask"><strong>pieces_mask</strong></a>(self, piece_type: 'PieceType', color: 'Color') -&gt; 'Bitboard'</dt></dl>

<dl><dt><a name="Board-pin"><strong>pin</strong></a>(self, color: 'Color', square: 'Square') -&gt; 'SquareSet'</dt><dd><tt>Detects&nbsp;an&nbsp;absolute&nbsp;pin&nbsp;(and&nbsp;its&nbsp;direction)&nbsp;of&nbsp;the&nbsp;given&nbsp;square&nbsp;to<br>
the&nbsp;king&nbsp;of&nbsp;the&nbsp;given&nbsp;color.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;import&nbsp;chess<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt;&nbsp;board&nbsp;=&nbsp;chess.<a href="#Board">Board</a>("rnb1k2r/ppp2ppp/5n2/3q4/1b1P4/2N5/PP3PPP/R1BQKBNR&nbsp;w&nbsp;KQkq&nbsp;-&nbsp;3&nbsp;7")<br>
&gt;&gt;&gt;&nbsp;board.<a href="#Board-is_pinned">is_pinned</a>(chess.WHITE,&nbsp;chess.C3)<br>
True<br>
&gt;&gt;&gt;&nbsp;direction&nbsp;=&nbsp;board.<a href="#Board-pin">pin</a>(chess.WHITE,&nbsp;chess.C3)<br>
&gt;&gt;&gt;&nbsp;direction<br>
SquareSet(0x0000_0001_0204_0810)<br>
&gt;&gt;&gt;&nbsp;print(direction)<br>
.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.<br>
.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.<br>
.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.<br>
1&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.<br>
.&nbsp;1&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.<br>
.&nbsp;.&nbsp;1&nbsp;.&nbsp;.&nbsp;.&nbsp;.&nbsp;.<br>
.&nbsp;.&nbsp;.&nbsp;1&nbsp;.&nbsp;.&nbsp;.&nbsp;.<br>
.&nbsp;.&nbsp;.&nbsp;.&nbsp;1&nbsp;.&nbsp;.&nbsp;.<br>
&nbsp;<br>
Returns&nbsp;a&nbsp;:class:`set&nbsp;of&nbsp;squares&nbsp;&lt;chess.SquareSet&gt;`&nbsp;that&nbsp;mask&nbsp;the&nbsp;rank,<br>
file&nbsp;or&nbsp;diagonal&nbsp;of&nbsp;the&nbsp;pin.&nbsp;If&nbsp;there&nbsp;is&nbsp;no&nbsp;pin,&nbsp;then&nbsp;a&nbsp;mask&nbsp;of&nbsp;the<br>
entire&nbsp;board&nbsp;is&nbsp;returned.</tt></dd></dl>

<dl><dt><a name="Board-pin_mask"><strong>pin_mask</strong></a>(self, color: 'Color', square: 'Square') -&gt; 'Bitboard'</dt></dl>

<dl><dt><a name="Board-unicode"><strong>unicode</strong></a>(self, *, invert_color: 'bool' = False, borders: 'bool' = False, empty_square: 'str' = '', orientation: 'Color' = True) -&gt; 'str'</dt><dd><tt>Returns&nbsp;a&nbsp;string&nbsp;representation&nbsp;of&nbsp;the&nbsp;board&nbsp;with&nbsp;Unicode&nbsp;pieces.<br>
Useful&nbsp;for&nbsp;pretty-printing&nbsp;to&nbsp;a&nbsp;terminal.<br>
&nbsp;<br>
:param&nbsp;invert_color:&nbsp;Invert&nbsp;color&nbsp;of&nbsp;the&nbsp;Unicode&nbsp;pieces.<br>
:param&nbsp;borders:&nbsp;Show&nbsp;borders&nbsp;and&nbsp;a&nbsp;coordinate&nbsp;margin.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="chess.html#BaseBoard">chess.BaseBoard</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Engine">class <strong>Engine</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Engine">Engine</a>(fenstr='rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR',&nbsp;cpu=2,&nbsp;ram=2048)<br>
&nbsp;<br>
<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Engine-__init__"><strong>__init__</strong></a>(self, fenstr='rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR', cpu=2, ram=2048)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Engine-check_win"><strong>check_win</strong></a>(self)</dt></dl>

<dl><dt><a name="Engine-engine_move"><strong>engine_move</strong></a>(self)</dt></dl>

<dl><dt><a name="Engine-engine_skill"><strong>engine_skill</strong></a>(self, rating=3000)</dt></dl>

<dl><dt><a name="Engine-get_capture"><strong>get_capture</strong></a>(self, move='a1a2')</dt></dl>

<dl><dt><a name="Engine-get_piece"><strong>get_piece</strong></a>(self, square='a1')</dt></dl>

<dl><dt><a name="Engine-opponent_move"><strong>opponent_move</strong></a>(self, move)</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Move">class <strong>Move</strong></a>(<a href="chess.html#Move">chess.Move</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Move">Move</a>(from_square:&nbsp;'Square',&nbsp;to_square:&nbsp;'Square',&nbsp;promotion:&nbsp;'Optional[PieceType]'&nbsp;=&nbsp;None,&nbsp;drop:&nbsp;'Optional[PieceType]'&nbsp;=&nbsp;None)&nbsp;-&amp;gt;&nbsp;None<br>
&nbsp;<br>
<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="robotic_chess.chess.html#Move">Move</a></dd>
<dd><a href="chess.html#Move">chess.Move</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__annotations__</strong> = {}</dl>

<hr>
Methods inherited from <a href="chess.html#Move">chess.Move</a>:<br>
<dl><dt><a name="Move-__bool__"><strong>__bool__</strong></a>(self) -&gt; 'bool'</dt></dl>

<dl><dt><a name="Move-__eq__"><strong>__eq__</strong></a>(self, other)</dt><dd><tt>Return&nbsp;self==value.</tt></dd></dl>

<dl><dt><a name="Move-__hash__"><strong>__hash__</strong></a>(self)</dt><dd><tt>Return&nbsp;hash(self).</tt></dd></dl>

<dl><dt><a name="Move-__init__"><strong>__init__</strong></a>(self, from_square: 'Square', to_square: 'Square', promotion: 'Optional[PieceType]' = None, drop: 'Optional[PieceType]' = None) -&gt; None</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Move-__repr__"><strong>__repr__</strong></a>(self) -&gt; 'str'</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Move-__str__"><strong>__str__</strong></a>(self) -&gt; 'str'</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="Move-uci"><strong>uci</strong></a>(self) -&gt; 'str'</dt><dd><tt>Gets&nbsp;a&nbsp;UCI&nbsp;string&nbsp;for&nbsp;the&nbsp;move.<br>
&nbsp;<br>
For&nbsp;example,&nbsp;a&nbsp;move&nbsp;from&nbsp;a7&nbsp;to&nbsp;a8&nbsp;would&nbsp;be&nbsp;``a7a8``&nbsp;or&nbsp;``a7a8q``<br>
(if&nbsp;the&nbsp;latter&nbsp;is&nbsp;a&nbsp;promotion&nbsp;to&nbsp;a&nbsp;queen).<br>
&nbsp;<br>
The&nbsp;UCI&nbsp;representation&nbsp;of&nbsp;a&nbsp;null&nbsp;move&nbsp;is&nbsp;``0000``.</tt></dd></dl>

<dl><dt><a name="Move-xboard"><strong>xboard</strong></a>(self) -&gt; 'str'</dt></dl>

<hr>
Class methods inherited from <a href="chess.html#Move">chess.Move</a>:<br>
<dl><dt><a name="Move-from_uci"><strong>from_uci</strong></a>(uci: 'str') -&gt; 'Move'<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Parses&nbsp;a&nbsp;UCI&nbsp;string.<br>
&nbsp;<br>
:raises:&nbsp;:exc:`InvalidMoveError`&nbsp;if&nbsp;the&nbsp;UCI&nbsp;string&nbsp;is&nbsp;invalid.</tt></dd></dl>

<dl><dt><a name="Move-null"><strong>null</strong></a>() -&gt; 'Move'<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Gets&nbsp;a&nbsp;null&nbsp;move.<br>
&nbsp;<br>
A&nbsp;null&nbsp;move&nbsp;just&nbsp;passes&nbsp;the&nbsp;turn&nbsp;to&nbsp;the&nbsp;other&nbsp;side&nbsp;(and&nbsp;possibly<br>
forfeits&nbsp;en&nbsp;passant&nbsp;capturing).&nbsp;Null&nbsp;moves&nbsp;evaluate&nbsp;to&nbsp;``False``&nbsp;in<br>
boolean&nbsp;contexts.<br>
&nbsp;<br>
&gt;&gt;&gt;&nbsp;import&nbsp;chess<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt;&nbsp;bool(chess.<a href="#Move">Move</a>.<a href="#Move-null">null</a>())<br>
False</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="chess.html#Move">chess.Move</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="chess.html#Move">chess.Move</a>:<br>
<dl><dt><strong>__dataclass_fields__</strong> = {'drop': Field(name='drop',type='Optional[PieceType]',def...appingproxy({}),kw_only=False,_field_type=_FIELD), 'from_square': Field(name='from_square',type='Square',default=&lt;...appingproxy({}),kw_only=False,_field_type=_FIELD), 'promotion': Field(name='promotion',type='Optional[PieceType]...appingproxy({}),kw_only=False,_field_type=_FIELD), 'to_square': Field(name='to_square',type='Square',default=&lt;da...appingproxy({}),kw_only=False,_field_type=_FIELD)}</dl>

<dl><dt><strong>__dataclass_params__</strong> = _DataclassParams(init=True,repr=True,eq=True,order=False,unsafe_hash=True,frozen=False)</dl>

<dl><dt><strong>__match_args__</strong> = ('from_square', 'to_square', 'promotion', 'drop')</dl>

<dl><dt><strong>drop</strong> = None</dl>

<dl><dt><strong>promotion</strong> = None</dl>

</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>stockfish_path</strong> = '/usr/local/bin/stockfish'</td></tr></table>
</body></html>